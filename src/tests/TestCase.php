<?php

namespace Tests;

use Illuminate\Foundation\Testing\TestCase as BaseTestCase;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;
use App\Models\{Branch, Product};

abstract class TestCase extends BaseTestCase
{
    use CreatesApplication, RefreshDatabase;

    /**
     * We don't auto-seed in tests; each test creates only what it needs.
     */
    protected $seed = false;

    /**
     * After the schema is migrated for each test, relax SQLite-only constraint
     * on the generated column `hq_token` to avoid opaque unique collisions.
     */
    protected function setUp(): void
    {
        parent::setUp();

        // Only for SQLite during tests
        if (
            config('database.default') === 'sqlite'
            && Schema::hasTable('branches')
            && Schema::hasColumn('branches', 'hq_token')
        ) {

            // 1) Attempt to drop the conventional unique index name
            try {
                DB::statement('DROP INDEX IF EXISTS branches_hq_token_unique');
            } catch (\Throwable $e) {
                // ignore
            }

            // 2) Fallback: find any UNIQUE index that covers hq_token and drop it
            try {
                $indexes = DB::select("PRAGMA index_list('branches')");
                foreach ($indexes as $idx) {
                    // In SQLite, 'unique' is 1 for unique indexes
                    if (!property_exists($idx, 'unique') || (int)$idx->unique !== 1) {
                        continue;
                    }
                    $cols = DB::select("PRAGMA index_info('{$idx->name}')");
                    foreach ($cols as $col) {
                        // 'name' holds the column name for that index segment
                        if (isset($col->name) && $col->name === 'hq_token') {
                            DB::statement("DROP INDEX IF EXISTS {$idx->name}");
                            break 2;
                        }
                    }
                }
            } catch (\Throwable $e) {
                // ignore – if we can't drop, tests may still pass
            }
        }
    }

    /**
     * Ensure there is at least one unit and return its id.
     * If units.code exists and is NOT NULL, we populate it.
     */
    protected function ensureBaseUnitId(): int
    {
        $id = (int) DB::table('units')->value('id');
        if (!$id) {
            $payload = [
                'name'       => 'PCS',
                'created_at' => now(),
                'updated_at' => now(),
            ];
            if (Schema::hasColumn('units', 'code')) {
                $payload['code'] = 'PCS';
            }
            $id = (int) DB::table('units')->insertGetId($payload);
        }
        return $id;
    }

    /**
     * Ensure a province exists and return its id (adds 'code' if required).
     */
    protected function ensureProvinceId(): int
    {
        if (!Schema::hasTable('provinces')) {
            return 0;
        }

        $id = DB::table('provinces')->value('id');
        if ($id) {
            return (int) $id;
        }

        return (int) DB::table('provinces')->insertGetId([
            'name'       => 'Default Province',
            'code'       => 'DP',
            'created_at' => now(),
            'updated_at' => now(),
        ]);
    }

    /**
     * Ensure a district exists for a given province and return its id.
     */
    protected function ensureDistrictId(int $provinceId): int
    {
        if (!Schema::hasTable('districts')) {
            return 0;
        }

        $id = DB::table('districts')->value('id');
        if ($id) {
            return (int) $id;
        }

        return (int) DB::table('districts')->insertGetId([
            'province_id' => $provinceId,
            'name'        => 'Default District',
            ...(Schema::hasColumn('districts', 'code') ? ['code' => 'DD'] : []),
            'created_at'  => now(),
            'updated_at'  => now(),
        ]);
    }

    /**
     * Create a branch with guaranteed-unique identity and valid scope
     * (fresh province/district) to avoid generated hq_token collisions.
     * Never inserts into hq_token (it's generated by DB).
     */
    protected function makeBranch(string $name, string $code, ?string $hqToken = null): Branch
    {
        // Force uniqueness on name/code to avoid reuse/collisions.
        $suffix = strtoupper(bin2hex(random_bytes(2)));
        $uniqueName = "{$name} {$suffix}";
        $uniqueCode = "{$code}{$suffix}";

        // If already exists (in same test), reuse
        if ($existing = Branch::where('code', $uniqueCode)->first()) {
            return $existing;
        }

        $payload = [
            'name'       => $uniqueName,
            'created_at' => now(),
            'updated_at' => now(),
        ];

        if (Schema::hasColumn('branches', 'code')) {
            $payload['code'] = $uniqueCode;
        }

        // Give each new branch its own province/district so generated token differs
        if (Schema::hasColumn('branches', 'province_id')) {
            $pCode = 'P' . strtoupper(bin2hex(random_bytes(2)));
            $provinceId = DB::table('provinces')->insertGetId([
                'name'       => 'Province ' . $pCode,
                ...(Schema::hasColumn('provinces', 'code') ? ['code' => $pCode] : []),
                'created_at' => now(),
                'updated_at' => now(),
            ]);
            $payload['province_id'] = $provinceId;

            if (Schema::hasColumn('branches', 'district_id')) {
                $dCode = 'D' . strtoupper(bin2hex(random_bytes(2)));
                $districtId = DB::table('districts')->insertGetId([
                    'province_id' => $provinceId,
                    'name'        => 'District ' . $dCode,
                    ...(Schema::hasColumn('districts', 'code') ? ['code' => $dCode] : []),
                    'created_at'  => now(),
                    'updated_at'  => now(),
                ]);
                $payload['district_id'] = $districtId;
            }
        }

        // Do NOT set hq_token here — DB generates it (and SQLite forbids inserting into generated cols)
        $id = (int) DB::table('branches')->insertGetId($payload);

        return Branch::findOrFail($id);
    }

    /**
     * Create a minimal product; fills required FKs if your schema has them.
     */
    protected function makeProduct(string $name = 'Shampoo'): Product
    {
        $payload = ['name' => $name];

        if (Schema::hasColumn('products', 'category_id')) {
            $categoryId = DB::table('categories')->value('id')
                ?? DB::table('categories')->insertGetId([
                    'name'       => 'General',
                    ...(Schema::hasColumn('categories', 'code') ? ['code' => 'GEN'] : []),
                    'created_at' => now(),
                    'updated_at' => now(),
                ]);
            $payload['category_id'] = $categoryId;
        }

        if (Schema::hasColumn('products', 'supplier_id')) {
            $supplierId = DB::table('suppliers')->value('id')
                ?? DB::table('suppliers')->insertGetId([
                    'name'       => 'Default Supplier',
                    ...(Schema::hasColumn('suppliers', 'code') ? ['code' => 'SUP' . substr(uniqid(), -5)] : []),
                    'created_at' => now(),
                    'updated_at' => now(),
                ]);
            $payload['supplier_id'] = $supplierId;
        }

        if (Schema::hasColumn('products', 'unit_id')) {
            $payload['unit_id'] = $this->ensureBaseUnitId();
        }

        if (Schema::hasColumn('products', 'sku')) {
            $payload['sku'] = strtoupper(uniqid('SKU'));
        }

        return Product::create($payload);
    }
}
